// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: broker.proto

/*
	Package broker is a generated protocol buffer package.

	It is generated from these files:
		broker.proto

	It has these top-level messages:
		HttpHeader
		HttpReqMeta
		HttpRespMeta
		GoByeBye
		CancelCall
		StartCall
		DataFrame
		CallResponse
		CallComplete
		ResourceAnnounce
		ClientHello
		ServerHello
		ClientMsg
		ServerMsg
*/
package broker

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type HttpHeader struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *HttpHeader) Reset()                    { *m = HttpHeader{} }
func (m *HttpHeader) String() string            { return proto.CompactTextString(m) }
func (*HttpHeader) ProtoMessage()               {}
func (*HttpHeader) Descriptor() ([]byte, []int) { return fileDescriptorBroker, []int{0} }

func (m *HttpHeader) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *HttpHeader) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type HttpReqMeta struct {
	Method     string        `protobuf:"bytes,1,opt,name=method,proto3" json:"method,omitempty"`
	RequestUrl string        `protobuf:"bytes,2,opt,name=request_url,json=requestUrl,proto3" json:"request_url,omitempty"`
	Headers    []*HttpHeader `protobuf:"bytes,3,rep,name=headers" json:"headers,omitempty"`
}

func (m *HttpReqMeta) Reset()                    { *m = HttpReqMeta{} }
func (m *HttpReqMeta) String() string            { return proto.CompactTextString(m) }
func (*HttpReqMeta) ProtoMessage()               {}
func (*HttpReqMeta) Descriptor() ([]byte, []int) { return fileDescriptorBroker, []int{1} }

func (m *HttpReqMeta) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *HttpReqMeta) GetRequestUrl() string {
	if m != nil {
		return m.RequestUrl
	}
	return ""
}

func (m *HttpReqMeta) GetHeaders() []*HttpHeader {
	if m != nil {
		return m.Headers
	}
	return nil
}

type HttpRespMeta struct {
	StatusCode int32         `protobuf:"varint,1,opt,name=status_code,json=statusCode,proto3" json:"status_code,omitempty"`
	Headers    []*HttpHeader `protobuf:"bytes,2,rep,name=headers" json:"headers,omitempty"`
}

func (m *HttpRespMeta) Reset()                    { *m = HttpRespMeta{} }
func (m *HttpRespMeta) String() string            { return proto.CompactTextString(m) }
func (*HttpRespMeta) ProtoMessage()               {}
func (*HttpRespMeta) Descriptor() ([]byte, []int) { return fileDescriptorBroker, []int{2} }

func (m *HttpRespMeta) GetStatusCode() int32 {
	if m != nil {
		return m.StatusCode
	}
	return 0
}

func (m *HttpRespMeta) GetHeaders() []*HttpHeader {
	if m != nil {
		return m.Headers
	}
	return nil
}

// C2S client is going to shut down of its own volition - please stop sending me stuff
type GoByeBye struct {
}

func (m *GoByeBye) Reset()                    { *m = GoByeBye{} }
func (m *GoByeBye) String() string            { return proto.CompactTextString(m) }
func (*GoByeBye) ProtoMessage()               {}
func (*GoByeBye) Descriptor() ([]byte, []int) { return fileDescriptorBroker, []int{3} }

// S2C request that you please shutdown that function
type CancelCall struct {
	CallId string `protobuf:"bytes,1,opt,name=call_id,json=callId,proto3" json:"call_id,omitempty"`
}

func (m *CancelCall) Reset()                    { *m = CancelCall{} }
func (m *CancelCall) String() string            { return proto.CompactTextString(m) }
func (*CancelCall) ProtoMessage()               {}
func (*CancelCall) Descriptor() ([]byte, []int) { return fileDescriptorBroker, []int{4} }

func (m *CancelCall) GetCallId() string {
	if m != nil {
		return m.CallId
	}
	return ""
}

// S2C ok boys - here's a call
type StartCall struct {
	CallId          string            `protobuf:"bytes,1,opt,name=call_id,json=callId,proto3" json:"call_id,omitempty"`
	Image           string            `protobuf:"bytes,2,opt,name=image,proto3" json:"image,omitempty"`
	Route           string            `protobuf:"bytes,3,opt,name=route,proto3" json:"route,omitempty"`
	App             string            `protobuf:"bytes,4,opt,name=app,proto3" json:"app,omitempty"`
	Tenant          string            `protobuf:"bytes,5,opt,name=tenant,proto3" json:"tenant,omitempty"`
	ContainerConfig map[string]string `protobuf:"bytes,6,rep,name=container_config,json=containerConfig" json:"container_config,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	HasInput        bool              `protobuf:"varint,7,opt,name=has_input,json=hasInput,proto3" json:"has_input,omitempty"`
	ContentType     string            `protobuf:"bytes,8,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	Format          string            `protobuf:"bytes,9,opt,name=format,proto3" json:"format,omitempty"`
	Type            string            `protobuf:"bytes,10,opt,name=type,proto3" json:"type,omitempty"`
	Timeout         int32             `protobuf:"varint,11,opt,name=timeout,proto3" json:"timeout,omitempty"`
	IdleTimeout     int32             `protobuf:"varint,12,opt,name=idle_timeout,json=idleTimeout,proto3" json:"idle_timeout,omitempty"`
	Memory          uint64            `protobuf:"varint,13,opt,name=memory,proto3" json:"memory,omitempty"`
	// Types that are valid to be assigned to Proto:
	//	*StartCall_Http
	Proto isStartCall_Proto `protobuf_oneof:"proto"`
}

func (m *StartCall) Reset()                    { *m = StartCall{} }
func (m *StartCall) String() string            { return proto.CompactTextString(m) }
func (*StartCall) ProtoMessage()               {}
func (*StartCall) Descriptor() ([]byte, []int) { return fileDescriptorBroker, []int{5} }

type isStartCall_Proto interface {
	isStartCall_Proto()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StartCall_Http struct {
	Http *HttpReqMeta `protobuf:"bytes,100,opt,name=http,oneof"`
}

func (*StartCall_Http) isStartCall_Proto() {}

func (m *StartCall) GetProto() isStartCall_Proto {
	if m != nil {
		return m.Proto
	}
	return nil
}

func (m *StartCall) GetCallId() string {
	if m != nil {
		return m.CallId
	}
	return ""
}

func (m *StartCall) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *StartCall) GetRoute() string {
	if m != nil {
		return m.Route
	}
	return ""
}

func (m *StartCall) GetApp() string {
	if m != nil {
		return m.App
	}
	return ""
}

func (m *StartCall) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *StartCall) GetContainerConfig() map[string]string {
	if m != nil {
		return m.ContainerConfig
	}
	return nil
}

func (m *StartCall) GetHasInput() bool {
	if m != nil {
		return m.HasInput
	}
	return false
}

func (m *StartCall) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *StartCall) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *StartCall) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *StartCall) GetTimeout() int32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *StartCall) GetIdleTimeout() int32 {
	if m != nil {
		return m.IdleTimeout
	}
	return 0
}

func (m *StartCall) GetMemory() uint64 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *StartCall) GetHttp() *HttpReqMeta {
	if x, ok := m.GetProto().(*StartCall_Http); ok {
		return x.Http
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StartCall) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StartCall_OneofMarshaler, _StartCall_OneofUnmarshaler, _StartCall_OneofSizer, []interface{}{
		(*StartCall_Http)(nil),
	}
}

func _StartCall_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StartCall)
	// proto
	switch x := m.Proto.(type) {
	case *StartCall_Http:
		_ = b.EncodeVarint(100<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Http); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("StartCall.Proto has unexpected type %T", x)
	}
	return nil
}

func _StartCall_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StartCall)
	switch tag {
	case 100: // proto.http
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HttpReqMeta)
		err := b.DecodeMessage(msg)
		m.Proto = &StartCall_Http{msg}
		return true, err
	default:
		return false, nil
	}
}

func _StartCall_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StartCall)
	// proto
	switch x := m.Proto.(type) {
	case *StartCall_Http:
		s := proto.Size(x.Http)
		n += proto.SizeVarint(100<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// S2C and C2S exchange  blob of data for a fn or log
type DataFrame struct {
	CallId string `protobuf:"bytes,1,opt,name=call_id,json=callId,proto3" json:"call_id,omitempty"`
	Data   []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	Eof    bool   `protobuf:"varint,3,opt,name=eof,proto3" json:"eof,omitempty"`
}

func (m *DataFrame) Reset()                    { *m = DataFrame{} }
func (m *DataFrame) String() string            { return proto.CompactTextString(m) }
func (*DataFrame) ProtoMessage()               {}
func (*DataFrame) Descriptor() ([]byte, []int) { return fileDescriptorBroker, []int{6} }

func (m *DataFrame) GetCallId() string {
	if m != nil {
		return m.CallId
	}
	return ""
}

func (m *DataFrame) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *DataFrame) GetEof() bool {
	if m != nil {
		return m.Eof
	}
	return false
}

// C2S Call has started to finish - data might not be here yet
type CallResponse struct {
	CallId      string `protobuf:"bytes,1,opt,name=call_id,json=callId,proto3" json:"call_id,omitempty"`
	Eof         bool   `protobuf:"varint,2,opt,name=eof,proto3" json:"eof,omitempty"`
	ContentType string `protobuf:"bytes,3,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	// Types that are valid to be assigned to Meta:
	//	*CallResponse_Http
	Meta isCallResponse_Meta `protobuf_oneof:"meta"`
}

func (m *CallResponse) Reset()                    { *m = CallResponse{} }
func (m *CallResponse) String() string            { return proto.CompactTextString(m) }
func (*CallResponse) ProtoMessage()               {}
func (*CallResponse) Descriptor() ([]byte, []int) { return fileDescriptorBroker, []int{7} }

type isCallResponse_Meta interface {
	isCallResponse_Meta()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CallResponse_Http struct {
	Http *HttpRespMeta `protobuf:"bytes,100,opt,name=http,oneof"`
}

func (*CallResponse_Http) isCallResponse_Meta() {}

func (m *CallResponse) GetMeta() isCallResponse_Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *CallResponse) GetCallId() string {
	if m != nil {
		return m.CallId
	}
	return ""
}

func (m *CallResponse) GetEof() bool {
	if m != nil {
		return m.Eof
	}
	return false
}

func (m *CallResponse) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *CallResponse) GetHttp() *HttpRespMeta {
	if x, ok := m.GetMeta().(*CallResponse_Http); ok {
		return x.Http
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CallResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CallResponse_OneofMarshaler, _CallResponse_OneofUnmarshaler, _CallResponse_OneofSizer, []interface{}{
		(*CallResponse_Http)(nil),
	}
}

func _CallResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CallResponse)
	// meta
	switch x := m.Meta.(type) {
	case *CallResponse_Http:
		_ = b.EncodeVarint(100<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Http); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CallResponse.Meta has unexpected type %T", x)
	}
	return nil
}

func _CallResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CallResponse)
	switch tag {
	case 100: // meta.http
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HttpRespMeta)
		err := b.DecodeMessage(msg)
		m.Meta = &CallResponse_Http{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CallResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CallResponse)
	// meta
	switch x := m.Meta.(type) {
	case *CallResponse_Http:
		s := proto.Size(x.Http)
		n += proto.SizeVarint(100<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// C2S call is really done - nothing more to see here for this call
type CallComplete struct {
	CallId string `protobuf:"bytes,1,opt,name=call_id,json=callId,proto3" json:"call_id,omitempty"`
	Error  string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *CallComplete) Reset()                    { *m = CallComplete{} }
func (m *CallComplete) String() string            { return proto.CompactTextString(m) }
func (*CallComplete) ProtoMessage()               {}
func (*CallComplete) Descriptor() ([]byte, []int) { return fileDescriptorBroker, []int{8} }

func (m *CallComplete) GetCallId() string {
	if m != nil {
		return m.CallId
	}
	return ""
}

func (m *CallComplete) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type ResourceAnnounce struct {
	MemUsed    float64 `protobuf:"fixed64,1,opt,name=mem_used,json=memUsed,proto3" json:"mem_used,omitempty"`
	CpuUsed    float64 `protobuf:"fixed64,2,opt,name=cpu_used,json=cpuUsed,proto3" json:"cpu_used,omitempty"`
	ImageState []byte  `protobuf:"bytes,3,opt,name=image_state,json=imageState,proto3" json:"image_state,omitempty"`
	HotState   []byte  `protobuf:"bytes,4,opt,name=hot_state,json=hotState,proto3" json:"hot_state,omitempty"`
}

func (m *ResourceAnnounce) Reset()                    { *m = ResourceAnnounce{} }
func (m *ResourceAnnounce) String() string            { return proto.CompactTextString(m) }
func (*ResourceAnnounce) ProtoMessage()               {}
func (*ResourceAnnounce) Descriptor() ([]byte, []int) { return fileDescriptorBroker, []int{9} }

func (m *ResourceAnnounce) GetMemUsed() float64 {
	if m != nil {
		return m.MemUsed
	}
	return 0
}

func (m *ResourceAnnounce) GetCpuUsed() float64 {
	if m != nil {
		return m.CpuUsed
	}
	return 0
}

func (m *ResourceAnnounce) GetImageState() []byte {
	if m != nil {
		return m.ImageState
	}
	return nil
}

func (m *ResourceAnnounce) GetHotState() []byte {
	if m != nil {
		return m.HotState
	}
	return nil
}

// C2S - Always sent as the first message by the client
// if
type ClientHello struct {
	ClientVersion string `protobuf:"bytes,1,opt,name=client_version,json=clientVersion,proto3" json:"client_version,omitempty"`
	Binding       string `protobuf:"bytes,2,opt,name=binding,proto3" json:"binding,omitempty"`
}

func (m *ClientHello) Reset()                    { *m = ClientHello{} }
func (m *ClientHello) String() string            { return proto.CompactTextString(m) }
func (*ClientHello) ProtoMessage()               {}
func (*ClientHello) Descriptor() ([]byte, []int) { return fileDescriptorBroker, []int{10} }

func (m *ClientHello) GetClientVersion() string {
	if m != nil {
		return m.ClientVersion
	}
	return ""
}

func (m *ClientHello) GetBinding() string {
	if m != nil {
		return m.Binding
	}
	return ""
}

type ServerHello struct {
	ServerVersion string `protobuf:"bytes,1,opt,name=server_version,json=serverVersion,proto3" json:"server_version,omitempty"`
}

func (m *ServerHello) Reset()                    { *m = ServerHello{} }
func (m *ServerHello) String() string            { return proto.CompactTextString(m) }
func (*ServerHello) ProtoMessage()               {}
func (*ServerHello) Descriptor() ([]byte, []int) { return fileDescriptorBroker, []int{11} }

func (m *ServerHello) GetServerVersion() string {
	if m != nil {
		return m.ServerVersion
	}
	return ""
}

type ClientMsg struct {
	// Types that are valid to be assigned to Body:
	//	*ClientMsg_CallRespond
	//	*ClientMsg_CallComplete
	//	*ClientMsg_Data
	//	*ClientMsg_Log
	//	*ClientMsg_Hello
	//	*ClientMsg_GoByeBye
	Body isClientMsg_Body `protobuf_oneof:"body"`
}

func (m *ClientMsg) Reset()                    { *m = ClientMsg{} }
func (m *ClientMsg) String() string            { return proto.CompactTextString(m) }
func (*ClientMsg) ProtoMessage()               {}
func (*ClientMsg) Descriptor() ([]byte, []int) { return fileDescriptorBroker, []int{12} }

type isClientMsg_Body interface {
	isClientMsg_Body()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClientMsg_CallRespond struct {
	CallRespond *CallResponse `protobuf:"bytes,1,opt,name=call_respond,json=callRespond,oneof"`
}
type ClientMsg_CallComplete struct {
	CallComplete *CallComplete `protobuf:"bytes,2,opt,name=call_complete,json=callComplete,oneof"`
}
type ClientMsg_Data struct {
	Data *DataFrame `protobuf:"bytes,3,opt,name=data,oneof"`
}
type ClientMsg_Log struct {
	Log *DataFrame `protobuf:"bytes,4,opt,name=log,oneof"`
}
type ClientMsg_Hello struct {
	Hello *ClientHello `protobuf:"bytes,5,opt,name=hello,oneof"`
}
type ClientMsg_GoByeBye struct {
	GoByeBye *GoByeBye `protobuf:"bytes,6,opt,name=go_bye_bye,json=goByeBye,oneof"`
}

func (*ClientMsg_CallRespond) isClientMsg_Body()  {}
func (*ClientMsg_CallComplete) isClientMsg_Body() {}
func (*ClientMsg_Data) isClientMsg_Body()         {}
func (*ClientMsg_Log) isClientMsg_Body()          {}
func (*ClientMsg_Hello) isClientMsg_Body()        {}
func (*ClientMsg_GoByeBye) isClientMsg_Body()     {}

func (m *ClientMsg) GetBody() isClientMsg_Body {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *ClientMsg) GetCallRespond() *CallResponse {
	if x, ok := m.GetBody().(*ClientMsg_CallRespond); ok {
		return x.CallRespond
	}
	return nil
}

func (m *ClientMsg) GetCallComplete() *CallComplete {
	if x, ok := m.GetBody().(*ClientMsg_CallComplete); ok {
		return x.CallComplete
	}
	return nil
}

func (m *ClientMsg) GetData() *DataFrame {
	if x, ok := m.GetBody().(*ClientMsg_Data); ok {
		return x.Data
	}
	return nil
}

func (m *ClientMsg) GetLog() *DataFrame {
	if x, ok := m.GetBody().(*ClientMsg_Log); ok {
		return x.Log
	}
	return nil
}

func (m *ClientMsg) GetHello() *ClientHello {
	if x, ok := m.GetBody().(*ClientMsg_Hello); ok {
		return x.Hello
	}
	return nil
}

func (m *ClientMsg) GetGoByeBye() *GoByeBye {
	if x, ok := m.GetBody().(*ClientMsg_GoByeBye); ok {
		return x.GoByeBye
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ClientMsg) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ClientMsg_OneofMarshaler, _ClientMsg_OneofUnmarshaler, _ClientMsg_OneofSizer, []interface{}{
		(*ClientMsg_CallRespond)(nil),
		(*ClientMsg_CallComplete)(nil),
		(*ClientMsg_Data)(nil),
		(*ClientMsg_Log)(nil),
		(*ClientMsg_Hello)(nil),
		(*ClientMsg_GoByeBye)(nil),
	}
}

func _ClientMsg_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ClientMsg)
	// body
	switch x := m.Body.(type) {
	case *ClientMsg_CallRespond:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CallRespond); err != nil {
			return err
		}
	case *ClientMsg_CallComplete:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CallComplete); err != nil {
			return err
		}
	case *ClientMsg_Data:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Data); err != nil {
			return err
		}
	case *ClientMsg_Log:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Log); err != nil {
			return err
		}
	case *ClientMsg_Hello:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Hello); err != nil {
			return err
		}
	case *ClientMsg_GoByeBye:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GoByeBye); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ClientMsg.Body has unexpected type %T", x)
	}
	return nil
}

func _ClientMsg_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ClientMsg)
	switch tag {
	case 1: // body.call_respond
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CallResponse)
		err := b.DecodeMessage(msg)
		m.Body = &ClientMsg_CallRespond{msg}
		return true, err
	case 2: // body.call_complete
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CallComplete)
		err := b.DecodeMessage(msg)
		m.Body = &ClientMsg_CallComplete{msg}
		return true, err
	case 3: // body.data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DataFrame)
		err := b.DecodeMessage(msg)
		m.Body = &ClientMsg_Data{msg}
		return true, err
	case 4: // body.log
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DataFrame)
		err := b.DecodeMessage(msg)
		m.Body = &ClientMsg_Log{msg}
		return true, err
	case 5: // body.hello
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClientHello)
		err := b.DecodeMessage(msg)
		m.Body = &ClientMsg_Hello{msg}
		return true, err
	case 6: // body.go_bye_bye
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GoByeBye)
		err := b.DecodeMessage(msg)
		m.Body = &ClientMsg_GoByeBye{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ClientMsg_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ClientMsg)
	// body
	switch x := m.Body.(type) {
	case *ClientMsg_CallRespond:
		s := proto.Size(x.CallRespond)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientMsg_CallComplete:
		s := proto.Size(x.CallComplete)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientMsg_Data:
		s := proto.Size(x.Data)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientMsg_Log:
		s := proto.Size(x.Log)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientMsg_Hello:
		s := proto.Size(x.Hello)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientMsg_GoByeBye:
		s := proto.Size(x.GoByeBye)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ServerMsg struct {
	// Types that are valid to be assigned to Body:
	//	*ServerMsg_StartCall
	//	*ServerMsg_Data
	//	*ServerMsg_ServerHello
	Body isServerMsg_Body `protobuf_oneof:"body"`
}

func (m *ServerMsg) Reset()                    { *m = ServerMsg{} }
func (m *ServerMsg) String() string            { return proto.CompactTextString(m) }
func (*ServerMsg) ProtoMessage()               {}
func (*ServerMsg) Descriptor() ([]byte, []int) { return fileDescriptorBroker, []int{13} }

type isServerMsg_Body interface {
	isServerMsg_Body()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ServerMsg_StartCall struct {
	StartCall *StartCall `protobuf:"bytes,1,opt,name=start_call,json=startCall,oneof"`
}
type ServerMsg_Data struct {
	Data *DataFrame `protobuf:"bytes,2,opt,name=data,oneof"`
}
type ServerMsg_ServerHello struct {
	ServerHello *ServerHello `protobuf:"bytes,3,opt,name=server_hello,json=serverHello,oneof"`
}

func (*ServerMsg_StartCall) isServerMsg_Body()   {}
func (*ServerMsg_Data) isServerMsg_Body()        {}
func (*ServerMsg_ServerHello) isServerMsg_Body() {}

func (m *ServerMsg) GetBody() isServerMsg_Body {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *ServerMsg) GetStartCall() *StartCall {
	if x, ok := m.GetBody().(*ServerMsg_StartCall); ok {
		return x.StartCall
	}
	return nil
}

func (m *ServerMsg) GetData() *DataFrame {
	if x, ok := m.GetBody().(*ServerMsg_Data); ok {
		return x.Data
	}
	return nil
}

func (m *ServerMsg) GetServerHello() *ServerHello {
	if x, ok := m.GetBody().(*ServerMsg_ServerHello); ok {
		return x.ServerHello
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ServerMsg) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ServerMsg_OneofMarshaler, _ServerMsg_OneofUnmarshaler, _ServerMsg_OneofSizer, []interface{}{
		(*ServerMsg_StartCall)(nil),
		(*ServerMsg_Data)(nil),
		(*ServerMsg_ServerHello)(nil),
	}
}

func _ServerMsg_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ServerMsg)
	// body
	switch x := m.Body.(type) {
	case *ServerMsg_StartCall:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StartCall); err != nil {
			return err
		}
	case *ServerMsg_Data:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Data); err != nil {
			return err
		}
	case *ServerMsg_ServerHello:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServerHello); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ServerMsg.Body has unexpected type %T", x)
	}
	return nil
}

func _ServerMsg_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ServerMsg)
	switch tag {
	case 1: // body.start_call
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StartCall)
		err := b.DecodeMessage(msg)
		m.Body = &ServerMsg_StartCall{msg}
		return true, err
	case 2: // body.data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DataFrame)
		err := b.DecodeMessage(msg)
		m.Body = &ServerMsg_Data{msg}
		return true, err
	case 3: // body.server_hello
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ServerHello)
		err := b.DecodeMessage(msg)
		m.Body = &ServerMsg_ServerHello{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ServerMsg_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ServerMsg)
	// body
	switch x := m.Body.(type) {
	case *ServerMsg_StartCall:
		s := proto.Size(x.StartCall)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ServerMsg_Data:
		s := proto.Size(x.Data)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ServerMsg_ServerHello:
		s := proto.Size(x.ServerHello)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*HttpHeader)(nil), "HttpHeader")
	proto.RegisterType((*HttpReqMeta)(nil), "HttpReqMeta")
	proto.RegisterType((*HttpRespMeta)(nil), "HttpRespMeta")
	proto.RegisterType((*GoByeBye)(nil), "GoByeBye")
	proto.RegisterType((*CancelCall)(nil), "CancelCall")
	proto.RegisterType((*StartCall)(nil), "StartCall")
	proto.RegisterType((*DataFrame)(nil), "DataFrame")
	proto.RegisterType((*CallResponse)(nil), "CallResponse")
	proto.RegisterType((*CallComplete)(nil), "CallComplete")
	proto.RegisterType((*ResourceAnnounce)(nil), "ResourceAnnounce")
	proto.RegisterType((*ClientHello)(nil), "ClientHello")
	proto.RegisterType((*ServerHello)(nil), "ServerHello")
	proto.RegisterType((*ClientMsg)(nil), "ClientMsg")
	proto.RegisterType((*ServerMsg)(nil), "ServerMsg")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Broker service

type BrokerClient interface {
	Engage(ctx context.Context, opts ...grpc.CallOption) (Broker_EngageClient, error)
}

type brokerClient struct {
	cc *grpc.ClientConn
}

func NewBrokerClient(cc *grpc.ClientConn) BrokerClient {
	return &brokerClient{cc}
}

func (c *brokerClient) Engage(ctx context.Context, opts ...grpc.CallOption) (Broker_EngageClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Broker_serviceDesc.Streams[0], c.cc, "/Broker/Engage", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerEngageClient{stream}
	return x, nil
}

type Broker_EngageClient interface {
	Send(*ClientMsg) error
	Recv() (*ServerMsg, error)
	grpc.ClientStream
}

type brokerEngageClient struct {
	grpc.ClientStream
}

func (x *brokerEngageClient) Send(m *ClientMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *brokerEngageClient) Recv() (*ServerMsg, error) {
	m := new(ServerMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Broker service

type BrokerServer interface {
	Engage(Broker_EngageServer) error
}

func RegisterBrokerServer(s *grpc.Server, srv BrokerServer) {
	s.RegisterService(&_Broker_serviceDesc, srv)
}

func _Broker_Engage_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BrokerServer).Engage(&brokerEngageServer{stream})
}

type Broker_EngageServer interface {
	Send(*ServerMsg) error
	Recv() (*ClientMsg, error)
	grpc.ServerStream
}

type brokerEngageServer struct {
	grpc.ServerStream
}

func (x *brokerEngageServer) Send(m *ServerMsg) error {
	return x.ServerStream.SendMsg(m)
}

func (x *brokerEngageServer) Recv() (*ClientMsg, error) {
	m := new(ClientMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Broker_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Broker",
	HandlerType: (*BrokerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Engage",
			Handler:       _Broker_Engage_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "broker.proto",
}

func (m *HttpHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBroker(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBroker(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *HttpReqMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpReqMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Method) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBroker(dAtA, i, uint64(len(m.Method)))
		i += copy(dAtA[i:], m.Method)
	}
	if len(m.RequestUrl) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBroker(dAtA, i, uint64(len(m.RequestUrl)))
		i += copy(dAtA[i:], m.RequestUrl)
	}
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintBroker(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HttpRespMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpRespMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StatusCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBroker(dAtA, i, uint64(m.StatusCode))
	}
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBroker(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GoByeBye) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoByeBye) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CancelCall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelCall) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CallId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBroker(dAtA, i, uint64(len(m.CallId)))
		i += copy(dAtA[i:], m.CallId)
	}
	return i, nil
}

func (m *StartCall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartCall) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CallId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBroker(dAtA, i, uint64(len(m.CallId)))
		i += copy(dAtA[i:], m.CallId)
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBroker(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.Route) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBroker(dAtA, i, uint64(len(m.Route)))
		i += copy(dAtA[i:], m.Route)
	}
	if len(m.App) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBroker(dAtA, i, uint64(len(m.App)))
		i += copy(dAtA[i:], m.App)
	}
	if len(m.Tenant) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBroker(dAtA, i, uint64(len(m.Tenant)))
		i += copy(dAtA[i:], m.Tenant)
	}
	if len(m.ContainerConfig) > 0 {
		for k, _ := range m.ContainerConfig {
			dAtA[i] = 0x32
			i++
			v := m.ContainerConfig[k]
			mapSize := 1 + len(k) + sovBroker(uint64(len(k))) + 1 + len(v) + sovBroker(uint64(len(v)))
			i = encodeVarintBroker(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintBroker(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintBroker(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.HasInput {
		dAtA[i] = 0x38
		i++
		if m.HasInput {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ContentType) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintBroker(dAtA, i, uint64(len(m.ContentType)))
		i += copy(dAtA[i:], m.ContentType)
	}
	if len(m.Format) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintBroker(dAtA, i, uint64(len(m.Format)))
		i += copy(dAtA[i:], m.Format)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintBroker(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Timeout != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintBroker(dAtA, i, uint64(m.Timeout))
	}
	if m.IdleTimeout != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintBroker(dAtA, i, uint64(m.IdleTimeout))
	}
	if m.Memory != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintBroker(dAtA, i, uint64(m.Memory))
	}
	if m.Proto != nil {
		nn1, err := m.Proto.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *StartCall_Http) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Http != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintBroker(dAtA, i, uint64(m.Http.Size()))
		n2, err := m.Http.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *DataFrame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataFrame) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CallId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBroker(dAtA, i, uint64(len(m.CallId)))
		i += copy(dAtA[i:], m.CallId)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBroker(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Eof {
		dAtA[i] = 0x18
		i++
		if m.Eof {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CallResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CallId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBroker(dAtA, i, uint64(len(m.CallId)))
		i += copy(dAtA[i:], m.CallId)
	}
	if m.Eof {
		dAtA[i] = 0x10
		i++
		if m.Eof {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ContentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBroker(dAtA, i, uint64(len(m.ContentType)))
		i += copy(dAtA[i:], m.ContentType)
	}
	if m.Meta != nil {
		nn3, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	return i, nil
}

func (m *CallResponse_Http) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Http != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintBroker(dAtA, i, uint64(m.Http.Size()))
		n4, err := m.Http.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *CallComplete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallComplete) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CallId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBroker(dAtA, i, uint64(len(m.CallId)))
		i += copy(dAtA[i:], m.CallId)
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBroker(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *ResourceAnnounce) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceAnnounce) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MemUsed != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemUsed))))
		i += 8
	}
	if m.CpuUsed != 0 {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuUsed))))
		i += 8
	}
	if len(m.ImageState) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBroker(dAtA, i, uint64(len(m.ImageState)))
		i += copy(dAtA[i:], m.ImageState)
	}
	if len(m.HotState) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBroker(dAtA, i, uint64(len(m.HotState)))
		i += copy(dAtA[i:], m.HotState)
	}
	return i, nil
}

func (m *ClientHello) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientHello) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClientVersion) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBroker(dAtA, i, uint64(len(m.ClientVersion)))
		i += copy(dAtA[i:], m.ClientVersion)
	}
	if len(m.Binding) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBroker(dAtA, i, uint64(len(m.Binding)))
		i += copy(dAtA[i:], m.Binding)
	}
	return i, nil
}

func (m *ServerHello) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerHello) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServerVersion) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBroker(dAtA, i, uint64(len(m.ServerVersion)))
		i += copy(dAtA[i:], m.ServerVersion)
	}
	return i, nil
}

func (m *ClientMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Body != nil {
		nn5, err := m.Body.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	return i, nil
}

func (m *ClientMsg_CallRespond) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CallRespond != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBroker(dAtA, i, uint64(m.CallRespond.Size()))
		n6, err := m.CallRespond.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *ClientMsg_CallComplete) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CallComplete != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBroker(dAtA, i, uint64(m.CallComplete.Size()))
		n7, err := m.CallComplete.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *ClientMsg_Data) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Data != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBroker(dAtA, i, uint64(m.Data.Size()))
		n8, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *ClientMsg_Log) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Log != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBroker(dAtA, i, uint64(m.Log.Size()))
		n9, err := m.Log.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *ClientMsg_Hello) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Hello != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBroker(dAtA, i, uint64(m.Hello.Size()))
		n10, err := m.Hello.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *ClientMsg_GoByeBye) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.GoByeBye != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintBroker(dAtA, i, uint64(m.GoByeBye.Size()))
		n11, err := m.GoByeBye.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *ServerMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Body != nil {
		nn12, err := m.Body.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn12
	}
	return i, nil
}

func (m *ServerMsg_StartCall) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StartCall != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBroker(dAtA, i, uint64(m.StartCall.Size()))
		n13, err := m.StartCall.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *ServerMsg_Data) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBroker(dAtA, i, uint64(m.Data.Size()))
		n14, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func (m *ServerMsg_ServerHello) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServerHello != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBroker(dAtA, i, uint64(m.ServerHello.Size()))
		n15, err := m.ServerHello.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func encodeVarintBroker(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *HttpHeader) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovBroker(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovBroker(uint64(l))
	}
	return n
}

func (m *HttpReqMeta) Size() (n int) {
	var l int
	_ = l
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovBroker(uint64(l))
	}
	l = len(m.RequestUrl)
	if l > 0 {
		n += 1 + l + sovBroker(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovBroker(uint64(l))
		}
	}
	return n
}

func (m *HttpRespMeta) Size() (n int) {
	var l int
	_ = l
	if m.StatusCode != 0 {
		n += 1 + sovBroker(uint64(m.StatusCode))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovBroker(uint64(l))
		}
	}
	return n
}

func (m *GoByeBye) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CancelCall) Size() (n int) {
	var l int
	_ = l
	l = len(m.CallId)
	if l > 0 {
		n += 1 + l + sovBroker(uint64(l))
	}
	return n
}

func (m *StartCall) Size() (n int) {
	var l int
	_ = l
	l = len(m.CallId)
	if l > 0 {
		n += 1 + l + sovBroker(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovBroker(uint64(l))
	}
	l = len(m.Route)
	if l > 0 {
		n += 1 + l + sovBroker(uint64(l))
	}
	l = len(m.App)
	if l > 0 {
		n += 1 + l + sovBroker(uint64(l))
	}
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovBroker(uint64(l))
	}
	if len(m.ContainerConfig) > 0 {
		for k, v := range m.ContainerConfig {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovBroker(uint64(len(k))) + 1 + len(v) + sovBroker(uint64(len(v)))
			n += mapEntrySize + 1 + sovBroker(uint64(mapEntrySize))
		}
	}
	if m.HasInput {
		n += 2
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovBroker(uint64(l))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovBroker(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovBroker(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovBroker(uint64(m.Timeout))
	}
	if m.IdleTimeout != 0 {
		n += 1 + sovBroker(uint64(m.IdleTimeout))
	}
	if m.Memory != 0 {
		n += 1 + sovBroker(uint64(m.Memory))
	}
	if m.Proto != nil {
		n += m.Proto.Size()
	}
	return n
}

func (m *StartCall_Http) Size() (n int) {
	var l int
	_ = l
	if m.Http != nil {
		l = m.Http.Size()
		n += 2 + l + sovBroker(uint64(l))
	}
	return n
}
func (m *DataFrame) Size() (n int) {
	var l int
	_ = l
	l = len(m.CallId)
	if l > 0 {
		n += 1 + l + sovBroker(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovBroker(uint64(l))
	}
	if m.Eof {
		n += 2
	}
	return n
}

func (m *CallResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.CallId)
	if l > 0 {
		n += 1 + l + sovBroker(uint64(l))
	}
	if m.Eof {
		n += 2
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovBroker(uint64(l))
	}
	if m.Meta != nil {
		n += m.Meta.Size()
	}
	return n
}

func (m *CallResponse_Http) Size() (n int) {
	var l int
	_ = l
	if m.Http != nil {
		l = m.Http.Size()
		n += 2 + l + sovBroker(uint64(l))
	}
	return n
}
func (m *CallComplete) Size() (n int) {
	var l int
	_ = l
	l = len(m.CallId)
	if l > 0 {
		n += 1 + l + sovBroker(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovBroker(uint64(l))
	}
	return n
}

func (m *ResourceAnnounce) Size() (n int) {
	var l int
	_ = l
	if m.MemUsed != 0 {
		n += 9
	}
	if m.CpuUsed != 0 {
		n += 9
	}
	l = len(m.ImageState)
	if l > 0 {
		n += 1 + l + sovBroker(uint64(l))
	}
	l = len(m.HotState)
	if l > 0 {
		n += 1 + l + sovBroker(uint64(l))
	}
	return n
}

func (m *ClientHello) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClientVersion)
	if l > 0 {
		n += 1 + l + sovBroker(uint64(l))
	}
	l = len(m.Binding)
	if l > 0 {
		n += 1 + l + sovBroker(uint64(l))
	}
	return n
}

func (m *ServerHello) Size() (n int) {
	var l int
	_ = l
	l = len(m.ServerVersion)
	if l > 0 {
		n += 1 + l + sovBroker(uint64(l))
	}
	return n
}

func (m *ClientMsg) Size() (n int) {
	var l int
	_ = l
	if m.Body != nil {
		n += m.Body.Size()
	}
	return n
}

func (m *ClientMsg_CallRespond) Size() (n int) {
	var l int
	_ = l
	if m.CallRespond != nil {
		l = m.CallRespond.Size()
		n += 1 + l + sovBroker(uint64(l))
	}
	return n
}
func (m *ClientMsg_CallComplete) Size() (n int) {
	var l int
	_ = l
	if m.CallComplete != nil {
		l = m.CallComplete.Size()
		n += 1 + l + sovBroker(uint64(l))
	}
	return n
}
func (m *ClientMsg_Data) Size() (n int) {
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovBroker(uint64(l))
	}
	return n
}
func (m *ClientMsg_Log) Size() (n int) {
	var l int
	_ = l
	if m.Log != nil {
		l = m.Log.Size()
		n += 1 + l + sovBroker(uint64(l))
	}
	return n
}
func (m *ClientMsg_Hello) Size() (n int) {
	var l int
	_ = l
	if m.Hello != nil {
		l = m.Hello.Size()
		n += 1 + l + sovBroker(uint64(l))
	}
	return n
}
func (m *ClientMsg_GoByeBye) Size() (n int) {
	var l int
	_ = l
	if m.GoByeBye != nil {
		l = m.GoByeBye.Size()
		n += 1 + l + sovBroker(uint64(l))
	}
	return n
}
func (m *ServerMsg) Size() (n int) {
	var l int
	_ = l
	if m.Body != nil {
		n += m.Body.Size()
	}
	return n
}

func (m *ServerMsg_StartCall) Size() (n int) {
	var l int
	_ = l
	if m.StartCall != nil {
		l = m.StartCall.Size()
		n += 1 + l + sovBroker(uint64(l))
	}
	return n
}
func (m *ServerMsg_Data) Size() (n int) {
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovBroker(uint64(l))
	}
	return n
}
func (m *ServerMsg_ServerHello) Size() (n int) {
	var l int
	_ = l
	if m.ServerHello != nil {
		l = m.ServerHello.Size()
		n += 1 + l + sovBroker(uint64(l))
	}
	return n
}

func sovBroker(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBroker(x uint64) (n int) {
	return sovBroker(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HttpHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBroker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBroker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBroker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpReqMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBroker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpReqMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpReqMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &HttpHeader{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBroker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBroker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpRespMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBroker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpRespMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpRespMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &HttpHeader{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBroker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBroker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoByeBye) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBroker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GoByeBye: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GoByeBye: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBroker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBroker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelCall) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBroker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelCall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelCall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBroker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBroker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartCall) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBroker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartCall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartCall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Route = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.App = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerConfig == nil {
				m.ContainerConfig = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBroker
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBroker
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBroker
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBroker
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthBroker
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBroker(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthBroker
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ContainerConfig[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasInput", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasInput = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
			}
			m.IdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleTimeout |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HttpReqMeta{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Proto = &StartCall_Http{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBroker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBroker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataFrame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBroker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataFrame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataFrame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eof", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eof = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBroker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBroker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBroker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eof", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eof = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HttpRespMeta{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Meta = &CallResponse_Http{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBroker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBroker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallComplete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBroker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallComplete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallComplete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBroker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBroker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceAnnounce) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBroker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceAnnounce: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceAnnounce: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemUsed", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemUsed = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUsed", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuUsed = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageState", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageState = append(m.ImageState[:0], dAtA[iNdEx:postIndex]...)
			if m.ImageState == nil {
				m.ImageState = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HotState", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HotState = append(m.HotState[:0], dAtA[iNdEx:postIndex]...)
			if m.HotState == nil {
				m.HotState = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBroker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBroker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientHello) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBroker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientHello: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientHello: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Binding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Binding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBroker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBroker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerHello) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBroker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerHello: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerHello: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBroker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBroker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBroker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallRespond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CallResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &ClientMsg_CallRespond{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallComplete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CallComplete{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &ClientMsg_CallComplete{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataFrame{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &ClientMsg_Data{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataFrame{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &ClientMsg_Log{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hello", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClientHello{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &ClientMsg_Hello{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoByeBye", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GoByeBye{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &ClientMsg_GoByeBye{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBroker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBroker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBroker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartCall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StartCall{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &ServerMsg_StartCall{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataFrame{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &ServerMsg_Data{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerHello", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBroker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServerHello{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &ServerMsg_ServerHello{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBroker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBroker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBroker(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBroker
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBroker
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthBroker
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBroker
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBroker(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBroker = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBroker   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("broker.proto", fileDescriptorBroker) }

var fileDescriptorBroker = []byte{
	// 913 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0xcd, 0x8e, 0xe3, 0x44,
	0x10, 0x8e, 0xf3, 0x9f, 0xb2, 0x07, 0x46, 0xad, 0x15, 0x98, 0x45, 0xca, 0x04, 0xb3, 0x2b, 0x05,
	0x21, 0x59, 0x30, 0xcc, 0x01, 0x21, 0x71, 0x20, 0x61, 0x21, 0xbb, 0xd2, 0x72, 0xf0, 0xec, 0xee,
	0xd5, 0xea, 0xd8, 0x35, 0x89, 0xb5, 0xb6, 0xdb, 0xdb, 0x6e, 0x8f, 0x94, 0x17, 0x40, 0xe2, 0xc6,
	0x05, 0x89, 0x47, 0xe2, 0xc8, 0x23, 0xa0, 0xe1, 0x25, 0x38, 0xa2, 0xae, 0x6e, 0x7b, 0xb2, 0x3f,
	0x8c, 0x38, 0x44, 0xf2, 0xf7, 0x55, 0x75, 0x75, 0xf5, 0xf7, 0x55, 0x77, 0xc0, 0xdb, 0x4a, 0xf1,
	0x12, 0x65, 0x58, 0x49, 0xa1, 0x44, 0x70, 0x01, 0xb0, 0x51, 0xaa, 0xda, 0x20, 0x4f, 0x51, 0xb2,
	0x53, 0x18, 0xbc, 0xc4, 0x83, 0xef, 0x2c, 0x9c, 0xe5, 0x2c, 0xd2, 0x9f, 0xec, 0x1e, 0x8c, 0xae,
	0x79, 0xde, 0xa0, 0xdf, 0x27, 0xce, 0x80, 0xa0, 0x00, 0x57, 0xaf, 0x8a, 0xf0, 0xd5, 0x53, 0x54,
	0x9c, 0x7d, 0x00, 0xe3, 0x02, 0xd5, 0x5e, 0xa4, 0x76, 0xa5, 0x45, 0xec, 0x0c, 0x5c, 0x89, 0xaf,
	0x1a, 0xac, 0x55, 0xdc, 0xc8, 0xdc, 0x96, 0x00, 0x4b, 0x3d, 0x97, 0x39, 0x7b, 0x08, 0x93, 0x3d,
	0xed, 0x5c, 0xfb, 0x83, 0xc5, 0x60, 0xe9, 0x9e, 0xbb, 0xe1, 0x6d, 0x37, 0x51, 0x1b, 0x0b, 0x5e,
	0x80, 0x67, 0xb6, 0xab, 0x2b, 0xda, 0xef, 0x0c, 0xdc, 0x5a, 0x71, 0xd5, 0xd4, 0x71, 0x22, 0x52,
	0xa4, 0x4d, 0x47, 0x11, 0x18, 0x6a, 0x2d, 0x52, 0x3c, 0xae, 0xdb, 0xbf, 0xa3, 0x2e, 0xc0, 0xf4,
	0x47, 0xb1, 0x3a, 0xe0, 0xea, 0x80, 0xc1, 0x43, 0x80, 0x35, 0x2f, 0x13, 0xcc, 0xd7, 0x3c, 0xcf,
	0xd9, 0x87, 0x30, 0x49, 0x78, 0x9e, 0xc7, 0x59, 0x77, 0x24, 0x0d, 0x1f, 0xa7, 0xc1, 0x3f, 0x03,
	0x98, 0x5d, 0x2a, 0x2e, 0xd5, 0x9d, 0x69, 0x5a, 0xb6, 0xac, 0xe0, 0xbb, 0x4e, 0x36, 0x02, 0x9a,
	0x95, 0xa2, 0x51, 0xe8, 0x0f, 0x0c, 0x4b, 0x40, 0x8b, 0xce, 0xab, 0xca, 0x1f, 0x1a, 0xd1, 0x79,
	0x55, 0x69, 0x3d, 0x15, 0x96, 0xbc, 0x54, 0xfe, 0xc8, 0x54, 0x35, 0x88, 0x3d, 0x81, 0xd3, 0x44,
	0x94, 0x8a, 0x67, 0x25, 0xca, 0x38, 0x11, 0xe5, 0x55, 0xb6, 0xf3, 0xc7, 0x74, 0xbe, 0xb3, 0xb0,
	0x6b, 0x2a, 0x5c, 0xb7, 0x29, 0x6b, 0xca, 0x78, 0x54, 0x2a, 0x79, 0x88, 0xde, 0x4f, 0x5e, 0x67,
	0xd9, 0xc7, 0x30, 0xdb, 0xf3, 0x3a, 0xce, 0xca, 0xaa, 0x51, 0xfe, 0x64, 0xe1, 0x2c, 0xa7, 0xd1,
	0x74, 0xcf, 0xeb, 0xc7, 0x1a, 0xb3, 0x4f, 0xc0, 0xd3, 0xf9, 0x58, 0xaa, 0x58, 0x1d, 0x2a, 0xf4,
	0xa7, 0xd4, 0x86, 0x6b, 0xb9, 0x67, 0x87, 0x0a, 0x75, 0x8f, 0x57, 0x42, 0x16, 0x5c, 0xf9, 0x33,
	0xd3, 0xa3, 0x41, 0x8c, 0xc1, 0x90, 0x96, 0x00, 0xb1, 0xf4, 0xcd, 0x7c, 0x98, 0xa8, 0xac, 0x40,
	0xd1, 0x28, 0xdf, 0x25, 0xaf, 0x5a, 0xa8, 0x37, 0xca, 0xd2, 0x1c, 0xe3, 0x36, 0xec, 0x51, 0xd8,
	0xd5, 0xdc, 0x33, 0x9b, 0x42, 0xc3, 0x55, 0x08, 0x79, 0xf0, 0x4f, 0x16, 0xce, 0x72, 0x18, 0x59,
	0xc4, 0x02, 0x18, 0xee, 0x95, 0xaa, 0xfc, 0x74, 0xe1, 0x2c, 0xdd, 0x73, 0x2f, 0x3c, 0x1a, 0xc8,
	0x4d, 0x2f, 0xa2, 0xd8, 0xfd, 0x15, 0xdc, 0x7b, 0x97, 0x1a, 0xff, 0x77, 0xce, 0xbf, 0xe9, 0x7f,
	0xed, 0xac, 0x26, 0x30, 0x32, 0x57, 0xe5, 0x09, 0xcc, 0xbe, 0xe7, 0x8a, 0xff, 0x20, 0x79, 0x81,
	0xff, 0xed, 0x3c, 0x83, 0x61, 0xca, 0x15, 0xa7, 0x3a, 0x5e, 0x44, 0xdf, 0x7a, 0x3b, 0x14, 0x57,
	0xe4, 0xfa, 0x34, 0xd2, 0x9f, 0xc1, 0x2f, 0x0e, 0x78, 0xda, 0x2c, 0x3d, 0xd2, 0xa2, 0xac, 0xef,
	0xa8, 0x67, 0xd7, 0xf6, 0xbb, 0xb5, 0x6f, 0x99, 0x33, 0x78, 0xdb, 0x9c, 0x4f, 0x5f, 0xd3, 0xe6,
	0x24, 0x3c, 0xbe, 0x3d, 0xad, 0x38, 0xab, 0x31, 0x0c, 0x0b, 0x54, 0x3c, 0xf8, 0xd6, 0xb4, 0xb2,
	0x16, 0x45, 0x95, 0xa3, 0xc2, 0x3b, 0x87, 0x1a, 0xa5, 0x14, 0xb2, 0xd5, 0x88, 0x40, 0xf0, 0xb3,
	0x03, 0xa7, 0x11, 0xd6, 0xa2, 0x91, 0x09, 0x7e, 0x57, 0x96, 0xa2, 0x29, 0x13, 0x64, 0x1f, 0xc1,
	0xb4, 0xc0, 0x22, 0x6e, 0x6a, 0x34, 0x45, 0x9c, 0x68, 0x52, 0x60, 0xf1, 0xbc, 0xc6, 0x54, 0x87,
	0x92, 0xaa, 0x31, 0xa1, 0xbe, 0x09, 0x25, 0x55, 0x43, 0xa1, 0x33, 0x70, 0xe9, 0xa2, 0xc4, 0xfa,
	0x2a, 0x9b, 0x83, 0x79, 0x11, 0x10, 0x75, 0xa9, 0x19, 0x1a, 0x5a, 0xa1, 0x6c, 0x78, 0x48, 0xe1,
	0xe9, 0x5e, 0x28, 0x0a, 0x06, 0x3f, 0x81, 0xbb, 0xce, 0x33, 0x2c, 0xd5, 0x06, 0xf3, 0x5c, 0xb0,
	0x87, 0xf0, 0x5e, 0x42, 0x30, 0xbe, 0x46, 0x59, 0x67, 0xa2, 0xb4, 0xa7, 0x39, 0x31, 0xec, 0x0b,
	0x43, 0xea, 0xd9, 0xdc, 0x66, 0x65, 0x9a, 0x95, 0x3b, 0x7b, 0xac, 0x16, 0x06, 0x17, 0xe0, 0x5e,
	0xa2, 0xbc, 0x46, 0xd9, 0xd5, 0xab, 0x09, 0xbe, 0x59, 0xcf, 0xb0, 0xb6, 0x5e, 0xf0, 0x6b, 0x1f,
	0x66, 0xa6, 0x8d, 0xa7, 0xf5, 0x8e, 0x9d, 0x83, 0x47, 0x5a, 0x4a, 0xf2, 0xd9, 0x68, 0xa1, 0x0d,
	0x39, 0xf6, 0x7e, 0xd3, 0x8b, 0xdc, 0xa4, 0xc3, 0x29, 0xbb, 0x80, 0x13, 0x5a, 0x93, 0x58, 0x43,
	0xa8, 0xaf, 0x76, 0x51, 0xeb, 0xd2, 0xa6, 0x17, 0x51, 0xe5, 0xce, 0xb5, 0x85, 0x9d, 0xbb, 0x01,
	0x25, 0x43, 0xd8, 0x8d, 0xaa, 0xf6, 0x9b, 0xa6, 0x70, 0x0e, 0x83, 0x5c, 0xec, 0x48, 0xb6, 0x37,
	0x13, 0x74, 0x80, 0x3d, 0x80, 0xd1, 0x5e, 0x9f, 0x94, 0x1e, 0x1d, 0x7d, 0xa3, 0x8e, 0xd4, 0xdc,
	0xf4, 0x22, 0x13, 0x64, 0x9f, 0x01, 0xec, 0x44, 0xbc, 0x3d, 0xa0, 0xfe, 0xf9, 0x63, 0x4a, 0x9d,
	0x85, 0xed, 0x33, 0xba, 0xe9, 0x45, 0xd3, 0x9d, 0xfd, 0xd6, 0x03, 0xb6, 0x15, 0xe9, 0x21, 0xf8,
	0xcd, 0x81, 0x99, 0x51, 0x52, 0x4b, 0xf2, 0x39, 0xe8, 0x97, 0x5a, 0xaa, 0x58, 0xb7, 0x6f, 0x05,
	0x81, 0xdb, 0xe7, 0x6b, 0xd3, 0x8b, 0x66, 0x75, 0xf7, 0xc0, 0x2e, 0x8e, 0x6e, 0xd3, 0xbb, 0x4f,
	0xf5, 0x25, 0x78, 0xd6, 0x16, 0xd3, 0xfc, 0xc0, 0x36, 0x7f, 0x64, 0x9d, 0x16, 0xb8, 0xbe, 0x85,
	0x6d, 0x5f, 0xe7, 0x21, 0x8c, 0x57, 0xf4, 0x5f, 0xc8, 0x1e, 0xc0, 0xf8, 0x51, 0xb9, 0xd3, 0x4f,
	0x34, 0x84, 0x9d, 0x79, 0xf7, 0x21, 0xec, 0xba, 0x5e, 0x3a, 0x5f, 0x38, 0xab, 0xd3, 0x3f, 0x6e,
	0xe6, 0xce, 0x9f, 0x37, 0x73, 0xe7, 0xaf, 0x9b, 0xb9, 0xf3, 0xfb, 0xdf, 0xf3, 0xde, 0x76, 0x4c,
	0x2f, 0xc3, 0x57, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0x87, 0xc2, 0x10, 0x7e, 0x54, 0x07, 0x00,
	0x00,
}
